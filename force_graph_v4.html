<!DOCTYPE html>
<meta charset="utf-8">
<style>
    body {
        overflow:hidden;
        margin:0;
    }

    text {
        font-family: sans-serif;
        pointer-events: none;
    }

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/d3-selection-multi.v1.js"></script>
<script>
    /* EMBEDS the graph.JSON file into the script because of work laptop firewall issues */
    /* Making the EDGE LABELS work */

    const INSTREAM_DATA = {
        "graph": [],
        "links": [
            {"source": 0, "target": 1, "label": "husband to" },
            {"source": 0, "target": 2, "label": "owner of" },
            {"source": 0, "target": 3, "label": "owner of" },
            {"source": 1, "target": 0, "label": "wife to" },
            {"source": 1, "target": 2, "label": "noona of" },
            {"source": 2, "target": 3, "label": "besties" }
        ],
        "nodes": [
            {"id": "Jon", "type": "square"},
            {"id": "Gretch", "type": "square"},
            {"id": "Patty", "type": "circle"},
            {"id": "Scrappy", "type": "circle"}
        ],
        "directed": false
    };

    const LOAD_FROM_FILE = false;

    //const INPUT_PATH = "graph.json";
    const INPUT_PATH = "graph2.json";

    let w = window.innerWidth;
    let h = window.innerHeight;

    //create SVG area
    const svg = d3.select("body").append("svg");
    svg.style("cursor","move");
    const chartArea = svg.append("g");

    /* BOOTSTRAP AND RUN!!! */
    if (LOAD_FROM_FILE) {
        d3.json(INPUT_PATH, (e, data) => {
            genGraph(data);
        });
    } else {
        genGraph(INSTREAM_DATA);
    }


    //MAIN
    function genGraph(data){
        //vars
        const LINK_DISTANCE = 100;

        const ALIGN_TEXT_CENTER = true;
        const DRAW_SOLID_NODES = true;

        const ZOOM_MIN = 0.1;
        const ZOOM_MAX = 7;

        const SCORE_MIN = 0;
        const SCORE_MAX = 1;

        const HIGHLIGHT_COLOR = "red";
        const HIGHLIGHT_OPACITY = 0.1;

        const BASE_NODE_COLOR_DEFAULT = "#ccc";
        const LINK_COLOR_DEFAULT = "#888";

        const BASE_NODE_SIZE_MIN = 8;
        const BASE_NODE_SIZE_MAX = 36;

        const TEXT_SIZE_MIN = 10;
        const TEXT_SIZE_MAX = 24;

        const STROKE_WIDTH_MIN = 1.5;
        const STROKE_WIDTH_MAX = 4.5;

        //computed vars
        const TO_COLOR = DRAW_SOLID_NODES ? "fill" : "stroke";
        const TO_WHITE = DRAW_SOLID_NODES ? "stroke" : "fill";

        const SIZE_SCALE = d3.scale.pow().exponent(1)
            .domain([1,100])
            .range([8,24]);

        const COLOR_SCALE = d3.scale.linear()
            .domain([SCORE_MIN, (SCORE_MIN + SCORE_MAX)/2, SCORE_MAX])
            .range(["lime", "yellow", "red"]);

        const zoom = d3.behavior.zoom().scaleExtent([ZOOM_MIN,ZOOM_MAX]);

        //dynamic vars
        var linkedByIndex = {};
        let focus_node = null;
        let highlight_node = null;

        let isKeyC = true,
            isKeyS = true,
            isKeyT = true,
            isKeyR = true,
            isKeyX = true,
            isKeyD = true,
            isKeyL = true,
            isKeyM = true,
            isKeyH = true,
            isKey1 = true,
            isKey2 = true,
            isKey3 = true,
            isKey0 = true;

        /* START PROCESS */
        data.links.forEach(function(d) {
            linkedByIndex[d.source + "," + d.target] = true;
        });

        const force = d3.layout.force()
            .linkDistance(LINK_DISTANCE)
            .charge(-300)
            .size([w,h]);

        force
            .nodes(data.nodes)
            .links(data.links)
            .start();

        /* EDGES as PATHS */
        const edgePaths = chartArea.selectAll(".edgepath")
            .data(data.links)
            .enter()
            .append('path')
            .attr('class', 'edgepath')
            .style("stroke-width",STROKE_WIDTH_MIN)
            .style("stroke", d => (isNumber(d.score) && d.score>=0) ? COLOR_SCALE(d.score) :  LINK_COLOR_DEFAULT)
            .attr('id', (d,i) => 'edgepath' + i)
            .attr('marker-end', 'url(#arrowhead)')
            .style("pointer-events", "none");

        const edgeLabels = chartArea.selectAll(".edgelabel")
            .data(data.links)
            .enter()
            .append("text")
            .style("pointer-events", "none")
            .attr('class', 'edgelabel')
            .attr('id', (d, i) => 'edgelabel' + i)
            .style('font-size', TEXT_SIZE_MIN + "px")
            .style('fill', '#aaa');

        edgeLabels.append('textPath')
            .attr('xlink:href', (d,i) => '#edgepath' + i)
            .style("text-anchor", "middle")
            .style("pointer-events", "none")
            .attr("startOffset", "50%")
            //.text((d,i) => 'label ' + i);
            .text(d => d.label);

        chartArea.append('defs')
            .append('marker')
            .attrs({'id':'arrowhead',
                'viewBox':'-0 -5 10 10',
                'refX':20, //offset from edge. takes node shape into account
                'refY':0,
                'orient':'auto',
                'markerWidth':7,
                'markerHeight':7,
                'xoverflow':'visible'})
            .append('svg:path')
            .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
            .attr('fill', '#999')
            .style('stroke','none');


        /* NODES/VERTICES as shapes*/
        const nodes = chartArea.selectAll(".node")
            .data(data.nodes)
            .enter().append("g")
            .attr("class", "node")
            .call(force.drag);

        //rects and circles drawn as PATH SVG elements
        const nodePaths = nodes.append("path")
            .attr("d", d3.svg.symbol()
                        .size(function(d) {
                                return Math.PI*Math.pow(SIZE_SCALE(d.size)||BASE_NODE_SIZE_MIN,2);
                            })
                        .type(function(d) {
                                return d.type;
                            }))
            .style(TO_COLOR, function(d) {
                    if (isNumber(d.score) && d.score>=0) {
                        return COLOR_SCALE(d.score);
                    }
                    else {
                        return BASE_NODE_COLOR_DEFAULT;
                    }
                })
            .style("stroke-width", STROKE_WIDTH_MIN)
            .style(TO_WHITE, "white");

        //add labels to the nodes
        const nodeLabels = chartArea.selectAll(".text")
            .data(data.nodes)
            .enter().append("text")
            .attr("dy", ".35em")
            .style("font-size", TEXT_SIZE_MIN + "px");

        if (ALIGN_TEXT_CENTER) {
            nodeLabels
                .text(d => d.id)
                .style("text-anchor", "middle");
        }
        else {
            nodeLabels
                .attr("dx", d => SIZE_SCALE(d.size) || BASE_NODE_SIZE_MIN)
                .text(d => '\u2002'+d.id);
        }

        /* MOUSE */
        //center double-clicked node
        nodes.on("dblclick.zoom", function(d) {
            d3.event.stopPropagation();
            const dcx = (window.innerWidth/2-d.x * zoom.scale());
            const dcy = (window.innerHeight/2-d.y * zoom.scale());
            zoom.translate([dcx,dcy]);
            chartArea.attr("transform", "translate("+ dcx + "," + dcy  + ")scale(" + zoom.scale() + ")");
        });

        //highlight on hover
        nodes.on("mouseover", function(d) {
                set_highlight(d);
            })
            .on("mouseout", function(d) {
                exit_highlight();
            });

        //remove non-adjacents on mouse down
        nodes.on("mousedown", function(d) {
            d3.event.stopPropagation();
            focus_node = d;
            set_focus(d);
            if (!highlight_node) {
                set_highlight(d)
            }
        });

        d3.select(window).on("mouseup", function() {
                if (focus_node) {
                    focus_node = null;
                    if (HIGHLIGHT_OPACITY < 1) {
                        nodePaths.style("opacity", 1);
                        nodeLabels.style("opacity", 1);
                        edgePaths.style("opacity", 1);
                    }
                }

                if (!highlight_node) {
                    exit_highlight();
                }
            });

        /* ZOOM */
        //set size of elements
        zoom.on("zoom", function() {
            const strokeWidth = (STROKE_WIDTH_MIN * zoom.scale() > STROKE_WIDTH_MAX) ? STROKE_WIDTH_MAX / zoom.scale() : STROKE_WIDTH_MIN;
            edgePaths.style("stroke-width",strokeWidth);
            nodePaths.style("stroke-width",strokeWidth);

            const base_radius = (BASE_NODE_SIZE_MIN * zoom.scale() > BASE_NODE_SIZE_MAX) ? BASE_NODE_SIZE_MAX / zoom.scale() : BASE_NODE_SIZE_MIN;
            nodePaths.attr("d", d3.svg.symbol()
                .size(d => Math.PI * Math.pow(SIZE_SCALE(d.size) * base_radius / BASE_NODE_SIZE_MIN || base_radius , 2))
                .type(d => d.type));

            if (!ALIGN_TEXT_CENTER) {
                nodeLabels.attr("dx", d => SIZE_SCALE(d.size) * base_radius / BASE_NODE_SIZE_MIN || base_radius)
            }

            const fontSize = (TEXT_SIZE_MIN*zoom.scale() > TEXT_SIZE_MAX) ? TEXT_SIZE_MAX / zoom.scale() : TEXT_SIZE_MIN;
            nodeLabels.style("font-size", fontSize + "px");
            chartArea.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
        });

        svg.call(zoom);
        handleResize();

        d3.select(window)
            .on("resize", handleResize)
            .on("keydown", handleKeypress);

        /* SIMULATION */
        //update position of nodes and edges
        force.on("tick", function() {
            nodes
                .attr("transform", d => "translate(" + d.x + "," + d.y + ")") //for rects
                .attr("cx", d => d.x) //for circles
                .attr("cy", d => d.y);

            nodeLabels.attr("transform", d => "translate(" + d.x + "," + d.y + ")");

            edgePaths.attr('d', d => 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y);

            edgeLabels.attr('transform', function(d){
                if (d.target.x < d.source.x){
                    const bbox = this.getBBox();
                    const rx = bbox.x + bbox.width / 2;
                    const ry = bbox.y + bbox.height / 2;
                    return 'rotate(180 ' + rx + ' ' + ry + ')';
                }
                else {
                    return 'rotate(0)';
                }
            });

        });

        /* UTILITY FUNCTIONS */
        function isConnected(a, b) {
            return linkedByIndex[a.index + "," + b.index] || linkedByIndex[b.index + "," + a.index] || a.index === b.index;
        }

        function hasConnections(a) {
            for (property in linkedByIndex) {
                s = property.split(",");
                if ((s[0] === a.index || s[1] === a.index) && linkedByIndex[property]) {
                    return true;
                }
            }

            return false;
        }

        function exit_highlight() {
            highlight_node = null;

            if (!focus_node) {
                svg.style("cursor","move");
                if (HIGHLIGHT_COLOR !== "white") {
                    nodePaths.style(TO_WHITE, "white");
                    nodeLabels.style("font-weight", "normal");
                    edgePaths.style("stroke", o => (isNumber(o.score) && o.score >= 0) ? COLOR_SCALE(o.score) : LINK_COLOR_DEFAULT);
                }
            }
        }

        function set_focus(d) {
            if (HIGHLIGHT_OPACITY < 1)  {
                nodePaths.style("opacity", o => isConnected(d, o) ? 1 : HIGHLIGHT_OPACITY);
                nodeLabels.style("opacity", o => isConnected(d, o) ? 1 : HIGHLIGHT_OPACITY);
                edgePaths.style("opacity", o => (o.source.index === d.index || o.target.index === d.index) ? 1 : HIGHLIGHT_OPACITY);
            }
        }

        function set_highlight(d) {
            svg.style("cursor", "pointer");

            if (focus_node) {
                d = focus_node;
            }

            highlight_node = d;

            if (HIGHLIGHT_COLOR !== "white") {
                nodePaths.style(TO_WHITE, o => isConnected(d, o) ? HIGHLIGHT_COLOR : "white");
                nodeLabels.style("font-weight", o => isConnected(d, o) ? "bold" : "normal");
                edgePaths.style("stroke", function(o) {
                    if (o.source.index === d.index || o.target.index === d.index) {
                        return HIGHLIGHT_COLOR;
                    }

                    if (isNumber(o.score) && o.score >= 0) {
                        return COLOR_SCALE(o.score);
                    }

                    return LINK_COLOR_DEFAULT;
                });
            }
        }

        function handleResize() {
            const currentWidth = window.innerWidth;
            const currentHeight = window.innerHeight;

            svg.attr("width", currentWidth).attr("height", currentHeight);

            force.size([force.size()[0] + (currentWidth - w) / zoom.scale(), force.size()[1] + (currentHeight - h) / zoom.scale()])
                .resume();

            w = currentWidth;
            h = currentHeight;
        }

        /* KEYSTROKE FX */
        function handleKeypress() {
            if (d3.event.keyCode === 32) {
                force.stop();
                return;
            }

            if (d3.event.keyCode >= 48 && d3.event.keyCode <= 90 && !d3.event.ctrlKey && !d3.event.altKey && !d3.event.metaKey) {
                switch (String.fromCharCode(d3.event.keyCode)) {
                    case "C": isKeyC = !isKeyC; break;
                    case "S": isKeyS = !isKeyS; break;
                    case "T": isKeyT = !isKeyT; break;
                    case "R": isKeyR = !isKeyR; break;
                    case "X": isKeyX = !isKeyX; break;
                    case "D": isKeyD = !isKeyD; break;
                    case "L": isKeyL = !isKeyL; break;
                    case "M": isKeyM = !isKeyM; break;
                    case "H": isKeyH = !isKeyH; break;
                    case "1": isKey1 = !isKey1; break;
                    case "2": isKey2 = !isKey2; break;
                    case "3": isKey3 = !isKey3; break;
                    case "0": isKey0 = !isKey0; break;
                }

                edgePaths.style("display", function(d) {
                        const shouldDisplay = shouldShowShape(d.source.type) && shouldShowShape(d.target.type) && shouldShowNodeScore(d.source.score)&&shouldShowNodeScore(d.target.score) && shouldShowEdgeScore(d.score);
                        linkedByIndex[d.source.index + "," + d.target.index] = shouldDisplay;
                        return shouldDisplay ? "inline" : "none";
                    });

                nodes.style("display", d => ((isKey0 || hasConnections(d)) && shouldShowShape(d.type) && shouldShowNodeScore(d.score)) ? "inline" : "none");
                nodeLabels.style("display", d => ((isKey0||hasConnections(d)) && shouldShowShape(d.type) && shouldShowNodeScore(d.score)) ? "inline" : "none");

                if (highlight_node) {
                    if ((isKey0 || hasConnections(highlight_node)) && shouldShowShape(highlight_node.type) && shouldShowNodeScore(highlight_node.score)) {
                        if (focus_node) {
                            set_focus(focus_node);
                        }

                        set_highlight(highlight_node);
                    } else {
                        exit_highlight();
                    }
                }
            }
        }

        /* VIS TOGGLES */
        //toggle visualization items by pressing key
        function shouldShowShape(type)
        {
            switch (type) {
                case "circle": return isKeyC;
                case "square": return isKeyS;
                case "triangle-up": return isKeyT;
                case "diamond": return isKeyR;
                case "cross": return isKeyX;
                case "triangle-down": return isKeyD;
                default: return true;
            }
        }

        //toggle visualization items by pressing key
        function shouldShowNodeScore(score)
        {
            if (isNumber(score))
            {
                if (score>=0.666) return isKeyH;
                else if (score>=0.333) return isKeyM;
                else if (score>=0) return isKeyL;
            }
            return true;
        }

        //toggle visualization items by pressing key
        function shouldShowEdgeScore(score)
        {
            if (isNumber(score))
            {
                if (score >= 0.666) return isKey3;
                else if (score>=0.333) return isKey2;
                else if (score>=0) return isKey1;
            }
            return true;
        }

        function isNumber(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }
    }
    //END OF MAIN

</script>
