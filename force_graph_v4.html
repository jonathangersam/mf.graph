<!DOCTYPE html>
<meta charset="utf-8">
<style>
    body {
        overflow:hidden;
        margin:0;
    }

    text {
        font-family: sans-serif;
        pointer-events: none;
    }

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>
    /* EMBEDS the graph.JSON file into the script because of work laptop firewall issues */
    /* Making the EDGE LABELS work */

    const INSTREAM_DATA = {
        "graph": [],
        "links": [
            {"source": 0, "target": 1, "label": "husband to" },
            {"source": 0, "target": 2, "label": "owner of" },
            {"source": 0, "target": 3, "label": "owner of" },
            {"source": 1, "target": 0, "label": "wife to" },
            {"source": 1, "target": 2, "label": "noona of" },
            {"source": 2, "target": 3, "label": "besties" }
        ],
        "nodes": [
            {"id": "Jon", "type": "square"},
            {"id": "Gretch", "type": "square"},
            {"id": "Patty", "type": "circle"},
            {"id": "Scrappy", "type": "circle"}
        ],
        "directed": false
    };

    const LOAD_FROM_FILE = false;

    //const INPUT_PATH = "graph.json";
    const INPUT_PATH = "graph2.json";

    let w = window.innerWidth;
    let h = window.innerHeight;

    //create SVG area
    const svg = d3.select("body").append("svg");
    svg.style("cursor","move");
    const chartArea = svg.append("g");

    /* BOOTSTRAP AND RUN!!! */
    if (LOAD_FROM_FILE) {
        d3.json(INPUT_PATH, (e, data) => {
            genGraph(data);
        });
    } else {
        genGraph(INSTREAM_DATA);
    }


    //MAIN
    function genGraph(data){
        //vars
        const ALIGN_TEXT_CENTER = true;
        const DRAW_SOLID_NODES = true;

        const ZOOM_MIN = 0.1;
        const ZOOM_MAX = 7;

        const SCORE_MIN = 0;
        const SCORE_MAX = 1;

        const HIGHLIGHT_COLOR = "red";
        const HIGHLIGHT_OPACITY = 0.1;

        const BASE_NODE_COLOR_DEFAULT = "#ccc";
        const LINK_COLOR_DEFAULT = "#888";

        const BASE_NODE_SIZE_MIN = 8;
        const BASE_NODE_SIZE_MAX = 36;

        const TEXT_SIZE_MIN = 10;
        const TEXT_SIZE_MAX = 24;

        const STROKE_WIDTH_MIN = 1.5;
        const STROKE_WIDTH_MAX = 4.5;

        //computed vars
        const TO_COLOR = DRAW_SOLID_NODES ? "fill" : "stroke";
        const TO_WHITE = DRAW_SOLID_NODES ? "stroke" : "fill";

        const SIZE_SCALE = d3.scale.pow().exponent(1)
            .domain([1,100])
            .range([8,24]);

        const COLOR_SCALE = d3.scale.linear()
            .domain([SCORE_MIN, (SCORE_MIN + SCORE_MAX)/2, SCORE_MAX])
            .range(["lime", "yellow", "red"]);

        const zoom = d3.behavior.zoom().scaleExtent([ZOOM_MIN,ZOOM_MAX]);

        //dynamic vars
        var linkedByIndex = {};
        let focus_node = null;
        let highlight_node = null;

        let isKeyC = true,
            isKeyS = true,
            isKeyT = true,
            isKeyR = true,
            isKeyX = true,
            isKeyD = true,
            isKeyL = true,
            isKeyM = true,
            isKeyH = true,
            isKey1 = true,
            isKey2 = true,
            isKey3 = true,
            isKey0 = true;

        /* START PROCESS */
        data.links.forEach(function(d) {
            linkedByIndex[d.source + "," + d.target] = true;
        });

        const force = d3.layout.force()
            .linkDistance(60)
            .charge(-300)
            .size([w,h]);

        force
            .nodes(data.nodes)
            .links(data.links)
            .start();

        //draw EDGES as LINES
        const edges = chartArea.selectAll(".link")
            .data(data.links)
            .enter()
            .append("line")
            .attr("class", "link")
            .style("stroke-width",STROKE_WIDTH_MIN)
            .style("stroke", d => (isNumber(d.score) && d.score>=0) ? COLOR_SCALE(d.score) :  LINK_COLOR_DEFAULT);


        //create NODES/VERTICES
        const nodes = chartArea.selectAll(".node")
            .data(data.nodes)
            .enter().append("g")
            .attr("class", "node")
            .call(force.drag);

        nodes.on("dblclick.zoom", function(d) {
                d3.event.stopPropagation();
                const dcx = (window.innerWidth/2-d.x * zoom.scale());
                const dcy = (window.innerHeight/2-d.y * zoom.scale());
                zoom.translate([dcx,dcy]);
                chartArea.attr("transform", "translate("+ dcx + "," + dcy  + ")scale(" + zoom.scale() + ")");
            });

        //rects and circles drawn as PATH SVG elements
        const nodePaths = nodes.append("path")
            .attr("d", d3.svg.symbol()
                        .size(function(d) {
                                return Math.PI*Math.pow(SIZE_SCALE(d.size)||BASE_NODE_SIZE_MIN,2);
                            })
                        .type(function(d) {
                                return d.type;
                            }))
            .style(TO_COLOR, function(d) {
                    if (isNumber(d.score) && d.score>=0) {
                        return COLOR_SCALE(d.score);
                    }
                    else {
                        return BASE_NODE_COLOR_DEFAULT;
                    }
                })
            .style("stroke-width", STROKE_WIDTH_MIN)
            .style(TO_WHITE, "white");


        //add labels to the nodes
        const nodeLabels = chartArea.selectAll(".text")
            .data(data.nodes)
            .enter().append("text")
            .attr("dy", ".35em")
            .style("font-size", TEXT_SIZE_MIN + "px");

        if (ALIGN_TEXT_CENTER) {
            nodeLabels
                .text(d => d.id)
                .style("text-anchor", "middle");
        }
        else {
            nodeLabels
                .attr("dx", d => SIZE_SCALE(d.size) || BASE_NODE_SIZE_MIN)
                .text(d => '\u2002'+d.id);
        }

        //apply mouseover highlighting
        nodes.on("mouseover", function(d) {
                set_highlight(d);
            })
            .on("mousedown", function(d) {
                d3.event.stopPropagation();
                focus_node = d;
                set_focus(d);
                if (highlight_node === null) set_highlight(d)

            })
            .on("mouseout", function(d) {
                exit_highlight();
            });

        //mouse up behavior
        d3.select(window).on("mouseup",
            function() {
                if (focus_node !== null)
                {
                    focus_node = null;
                    if (HIGHLIGHT_OPACITY < 1)
                    {
                        nodePaths.style("opacity", 1);
                        nodeLabels.style("opacity", 1);
                        edges.style("opacity", 1);
                    }
                }

                if (highlight_node === null) {
                    exit_highlight();
                }
            });

        zoom.on("zoom", function() {
            let stroke = STROKE_WIDTH_MIN;
            if (STROKE_WIDTH_MIN*zoom.scale() > STROKE_WIDTH_MAX) {
                stroke = STROKE_WIDTH_MAX/zoom.scale();
            }

            edges.style("stroke-width",stroke);
            nodePaths.style("stroke-width",stroke);

            let base_radius = BASE_NODE_SIZE_MIN;

            if (BASE_NODE_SIZE_MIN*zoom.scale() > BASE_NODE_SIZE_MAX) {
                base_radius = BASE_NODE_SIZE_MAX/zoom.scale();
            }

            nodePaths.attr("d", d3.svg.symbol()
                .size(function(d) { return Math.PI*Math.pow(SIZE_SCALE(d.size)*base_radius/BASE_NODE_SIZE_MIN||base_radius,2); })
                .type(function(d) { return d.type; }));

            if (!ALIGN_TEXT_CENTER) {
                nodeLabels.attr("dx", function(d) {
                    return (SIZE_SCALE(d.size)*base_radius/BASE_NODE_SIZE_MIN||base_radius);
                });
            }

            let text_size = TEXT_SIZE_MIN;

            if (TEXT_SIZE_MIN*zoom.scale()>TEXT_SIZE_MAX) {
                text_size = TEXT_SIZE_MAX/zoom.scale();
            }

            nodeLabels.style("font-size",text_size + "px");

            chartArea.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
        });

        svg.call(zoom);
        resize();

        d3.select(window)
            .on("resize", resize)
            .on("keydown", keydown);

        //set simulation effects
        force.on("tick", function() {
            nodes.attr("transform", function(d) {
                    return "translate(" + d.x + "," + d.y + ")";
                });

            nodeLabels.attr("transform", function(d) {
                    return "translate(" + d.x + "," + d.y + ")";
                });

            edges.attr("x1", function(d) { return d.source.x; })
                .attr("y1", function(d) { return d.source.y; })
                .attr("x2", function(d) { return d.target.x; })
                .attr("y2", function(d) { return d.target.y; });

            nodes.attr("cx", function(d) { return d.x; })
                .attr("cy", function(d) { return d.y; });
        });

        /* UTILITY FUNCTIONS */
        function isConnected(a, b) {
            return linkedByIndex[a.index + "," + b.index] || linkedByIndex[b.index + "," + a.index] || a.index === b.index;
        }

        function hasConnections(a) {
            for (property in linkedByIndex) {
                s = property.split(",");
                if ((s[0] === a.index || s[1] === a.index) && linkedByIndex[property]) {
                    return true;
                }
            }
            return false;
        }

        function exit_highlight()
        {
            highlight_node = null;

            if (focus_node === null)
            {
                svg.style("cursor","move");
                if (HIGHLIGHT_COLOR!=="white")
                {
                    nodePaths.style(TO_WHITE, "white");
                    nodeLabels.style("font-weight", "normal");
                    edges.style("stroke", function(o) {
                        return (isNumber(o.score) && o.score >= 0) ? COLOR_SCALE(o.score) : LINK_COLOR_DEFAULT;
                    });
                }

            }
        }

        function set_focus(d)
        {
            if (HIGHLIGHT_OPACITY < 1)  {
                nodePaths.style("opacity", function(o) {
                    return isConnected(d, o) ? 1 : HIGHLIGHT_OPACITY;
                });

                nodeLabels.style("opacity", function(o) {
                    return isConnected(d, o) ? 1 : HIGHLIGHT_OPACITY;
                });

                edges.style("opacity", function(o) {
                    return o.source.index === d.index || o.target.index === d.index ? 1 : HIGHLIGHT_OPACITY;
                });
            }
        }

        function set_highlight(d) {
            svg.style("cursor","pointer");

            if (focus_node!==null) {
                d = focus_node;
            }

            highlight_node = d;

            if (HIGHLIGHT_COLOR !== "white") {
                nodePaths.style(TO_WHITE, function(o) {
                    return isConnected(d, o) ? HIGHLIGHT_COLOR : "white";});

                nodeLabels.style("font-weight", function(o) {
                    return isConnected(d, o) ? "bold" : "normal";});

                edges.style("stroke", function(o) {
                    if (o.source.index === d.index || o.target.index === d.index) {
                        return HIGHLIGHT_COLOR;
                    }

                    if (isNumber(o.score) && o.score >= 0) {
                        return COLOR_SCALE(o.score);
                    }

                    return LINK_COLOR_DEFAULT;
                });
            }
        }

        function resize() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            svg.attr("width", width).attr("height", height);

            force.size([force.size()[0]+(width-w)/zoom.scale(),force.size()[1]+(height-h)/zoom.scale()])
                .resume();

            w = width;
            h = height;
        }

        /* KEYSTROKE FX */
        function keydown() {
            if (d3.event.keyCode === 32) {
                force.stop();
            }
            else if (d3.event.keyCode >= 48 && d3.event.keyCode <= 90 && !d3.event.ctrlKey && !d3.event.altKey && !d3.event.metaKey) {
                switch (String.fromCharCode(d3.event.keyCode)) {
                    case "C": isKeyC = !isKeyC; break;
                    case "S": isKeyS = !isKeyS; break;
                    case "T": isKeyT = !isKeyT; break;
                    case "R": isKeyR = !isKeyR; break;
                    case "X": isKeyX = !isKeyX; break;
                    case "D": isKeyD = !isKeyD; break;
                    case "L": isKeyL = !isKeyL; break;
                    case "M": isKeyM = !isKeyM; break;
                    case "H": isKeyH = !isKeyH; break;
                    case "1": isKey1 = !isKey1; break;
                    case "2": isKey2 = !isKey2; break;
                    case "3": isKey3 = !isKey3; break;
                    case "0": isKey0 = !isKey0; break;
                }

                edges.style("display", function(d) {
                        const flag = vis_by_type(d.source.type)&&vis_by_type(d.target.type)&&vis_by_node_score(d.source.score)&&vis_by_node_score(d.target.score)&&vis_by_link_score(d.score);
                        linkedByIndex[d.source.index + "," + d.target.index] = flag;
                        return flag ? "inline" : "none";
                    });

                nodes.style("display", function(d) {
                        if ((isKey0 || hasConnections(d)) && vis_by_type(d.type) && vis_by_node_score(d.score)) {
                            return "inline";
                        }

                        return "none";
                    });

                nodeLabels.style("display", function(d) {
                        if ((isKey0||hasConnections(d))&&vis_by_type(d.type)&&vis_by_node_score(d.score)) {
                            return "inline";
                        }

                        return "none";
                    });

                if (highlight_node !== null) {
                    if ((isKey0 || hasConnections(highlight_node)) && vis_by_type(highlight_node.type) && vis_by_node_score(highlight_node.score)) {
                        if (focus_node!==null) {
                            set_focus(focus_node);
                        }

                        set_highlight(highlight_node);
                    } else {
                        exit_highlight();
                    }
                }
            }
        }

        /* VIS TOGGLES */
        //toggle visualization items by pressing key
        function vis_by_type(type)
        {
            switch (type) {
                case "circle": return isKeyC;
                case "square": return isKeyS;
                case "triangle-up": return isKeyT;
                case "diamond": return isKeyR;
                case "cross": return isKeyX;
                case "triangle-down": return isKeyD;
                default: return true;
            }
        }

        //toggle visualization items by pressing key
        function vis_by_node_score(score)
        {
            if (isNumber(score))
            {
                if (score>=0.666) return isKeyH;
                else if (score>=0.333) return isKeyM;
                else if (score>=0) return isKeyL;
            }
            return true;
        }

        //toggle visualization items by pressing key
        function vis_by_link_score(score)
        {
            if (isNumber(score))
            {
                if (score >= 0.666) return isKey3;
                else if (score>=0.333) return isKey2;
                else if (score>=0) return isKey1;
            }
            return true;
        }

        function isNumber(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }
    }
    //END OF MAIN

</script>
