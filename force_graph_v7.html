<!DOCTYPE html>
<meta charset="utf-8">
<style>
    body {
        overflow:hidden;
        margin:0;
    }

    text {
        font-family: sans-serif;
        pointer-events: none;
    }

    .node {
        fill: #40a2e5;
        stroke-width: none;
    }
    .node.reachable {
        fill: #4fc2e5;
    }
    .node.fixed {
        fill: orange;
    }
    .node.focused {
        stroke: red;
        stroke-width: 1.5;
    }

    .nodelabel {
        fill: black;
        font-size: 7px;
        font-weight: normal;
        text-anchor: middle;
    }
    .nodelabel.focused {
        font-weight: bold;
    }


    .edge {
        stroke: #c6c6c6;
        stroke-width: 1.5;
    }
    .edge.fixed {
        stroke: orange;
    }
    .edge.focused {
        stroke: red;
    }

    .edgelabel {
        fill: #c6c6c6;
        font-size: 6px;
        font-weight: normal;
        text-anchor: middle;
    }
    .edgelabel.fixed {
        fill: orange;
    }
    .edgelabel.focused {
        fill: red;
        font-weight: bold;
    }

    .unfocused {
        opacity: 0.5
    }

    text.unfocused {
        opacity: 0;
    }


    .arrowhead {
        stroke: none;
    }

    #arrowheadneutral {
        fill: #c6c6c6;
    }
    #arrowheadfocused {
        fill: red;
    }
    #arrowheadunfocused {
        fill: #ceedf9;
    }
    #arrowheadfixed {
        fill: orange;
    }


</style>
<body>
    <div class="focused">
        <h4>Project Saturn v0.7</h4>
    </div>
<script src="http://d3js.org/d3.v4.min.js"></script>
<script src="http://d3js.org/d3-selection-multi.v1.js"></script>
<script>
	/* V7: use edge id to identify edges. to support dynamic add/delete of nodes */

    /* EMBEDS the graph.JSON file into the script because of work laptop firewall issues */
    /* Making the EDGE LABELS work */

    const MY_DATA = {
        "nodes": [
            {"id": "Jon"},
            {"id": "Greta"},
            {"id": "Scrappy"},
            {"id": "Patty"},
            {"id": "Panda"},
            {"id": "Pet"},
            {"id": "The GodFanda"},
            {"id": "Rich"},
            {"id": "Lucky"}
        ],
        "edges": [
            {"id": 0, "source": 0, "target": 1, "label": "loves"},
            {"id": 1, "source": 0, "target": 2, "label": "pets"},
            {"id": 2, "source": 1, "target": 3, "label": "Is Noona of"},
            {"id": 3, "source": 0, "target": 3, "label": "Kicks"},
            {"id": 4, "source": 3, "target": 2, "label": "Is Besties With"},
            {"id": 5, "source": 3, "target": 4, "label": "Is-a"},
            {"id": 6, "source": 3, "target": 5, "label": "Is-a"},
            {"id": 7, "source": 3, "target": 6, "label": "Is-the"},
            {"id": 8, "source": 3, "target": 7, "label": "Is-really"},
            {"id": 9, "source": 3, "target": 8, "label": "Is-quite"},
            {"id": 10, "source": 3, "target": 7, "label": "R-E-A-L-L-Y"}
        ]
    };


    const INSTREAM_DATA = MY_DATA;

    const LOAD_FROM_FILE = false;
    const INPUT_PATH = "graph2.json";

    const w = window.innerWidth;
    const h = window.innerHeight;

    //create SVG area
    const svg = d3.select("body").append("svg");
    svg.attr("width", w)
        .attr("height", h);
    //svg.style("cursor","move");
    const chartArea = svg.append("g");

    /* BOOTSTRAP AND RUN!!! */
    if (LOAD_FROM_FILE) {
        d3.json(INPUT_PATH, (e, data) => {
            genGraph(data);
        });
    } else {
        genGraph(INSTREAM_DATA);
    }


    /*
    TODOS
    / extract node-removal code into own function
    / use masterGraph index as ID
    - FP-ize the filters
    - the filter-out pattern should be extracted to a higher-order function
    - remove Edge ID concept. use their array index instead
    / update linkedNodes after removing nodes
    - try restoring of nodes and links
    / for linked nodes that have several edges, concatenate those edge labels.
    / fix: right-clicking node to toggle "fixed"d class removes focus. split function on removing focused and unfocused classes
    ... adaptive framerate for large number of nodes. A: seems D3 already auto-adapts (ie tick is a callback, when no sim updates, its not called.)
	- on window resize, center the graph again
	- add lines to visualize edges (in addition to paths) - will this be more efficient for visualization?
	/ add: node:mouseover: pop the hovered node
    - try if using lines instead of paths is better. and can you still have the arrowheads w/ path stroke=none?
    - index.js CSV to JSON converter: foreach edge: if node-target combo is present already, update existing's edge by concatenating the new edge.
     */

    //MAIN
    function genGraph(data){
        //switches
        const EDGELABEL_KEEP_UPRIGHT = false;
        const SHOW_EDGES = true;
        const SHOW_EDGE_ARROWHEADS = true;
        const ADAPTIVERENDERER_TICKSKIP_MAXFRAMES = 0;
        const ADAPTIVERENDERER_TICKSKIP_MAXWAIT = 200; //in ms
        const NODEDRAG_FIXES_POSITION = false;
        const NODE_COLLISION_PADDING = 1;

        //sim settings
        const LINK_DISTANCE = 100;
        const GRAPH_CHARGE = -100;
        const NODE_RADIUS = 20;
        const NODE_POP_SIZE = 5;
        const EDGE_ARROWHEAD_OFFSET = 30; //distance from tip of an edge. adjust based on node radius

        const timings = {
            nodePop: 400,
            nodeExit: 200,
            nodeEnter: 800
        };

        //special classnames
        const classnames = {
            node: "node",
            nodeLabel: "nodelabel",
            edge: "edge",
            edgeLabel: "edgelabel",
            focused: "focused",
            unfocused: "unfocused",
            fixed: "fixed",
            reachable: "reachable",
            arrowhead: "arrowhead"
        };
        
        const ids = {
            arrowheadNeutral: "arrowheadneutral",
            arrowheadFocused: "arrowheadfocused",
            arrowheadUnfocused: "arrowheadunfocused",
            arrowheadFixed: "arrowheadfixed"
        };

        /* INITIALIZATIONS */

        //make independent local copy
        const graphMaster = cloneGraph(data);

        let graphCurrentSelection = {
            nodes: graphMaster.nodes.filter(d => true),
            edges: graphMaster.edges.filter(d => true)
        };

        /* DRAW NODES AND EDGES */
        createArrowheads();

        let edges = chartArea.append('g').attr('class', 'layeredges').selectAll("." + classnames.edge);
        let edgeLabels = chartArea.append('g').attr('class', 'layeredgelabels').selectAll("." + classnames.edgeLabel);
        let nodes = chartArea.append('g').attr('class', 'layernodes').selectAll("." + classnames.node);
        let nodeLabels = chartArea.append('g').attr('class', 'layernodelabels').selectAll("." + classnames.nodeLabel);

        redraw(graphCurrentSelection.nodes, graphCurrentSelection.edges);

        /* SETUP SIMULATION */

        //Setup simulation Forces
        const simulation = d3.forceSimulation()
            .force("link", d3.forceLink().distance(LINK_DISTANCE))
            .force("collide", d3.forceCollide().radius(() => NODE_RADIUS + NODE_COLLISION_PADDING).iterations(2))
            .force("charge", d3.forceManyBody().strength(GRAPH_CHARGE))
            .force("center", d3.forceCenter(w / 2, h / 2)); //todo: convert to +svg.attr("width"), +svg.attr("width")

        //const framerateController =
        // new AdaptiveFramerate(ADAPTIVERENDERER_TICKSKIP_MAXFRAMES, ADAPTIVERENDERER_TICKSKIP_MAXWAIT);
        let skipFrames = ADAPTIVERENDERER_TICKSKIP_MAXFRAMES;

        simulation
            .nodes(graphCurrentSelection.nodes)
            .on("tick", d => {
//              console.log('ticked at', new Date());
//              if (!framerateController.isTimeForUpdate()) {
//                  return;
//              }
                skipFrames--;
                if (skipFrames > 0) {
                    return;
                }
                skipFrames = ADAPTIVERENDERER_TICKSKIP_MAXFRAMES;

                ticked();
            });

        simulation.force("link")
            .links(graphCurrentSelection.edges);

        //d3.select(window).on("mouseup", removeFocusAndUnfocusClasses);
        d3.select(window)
        //.on("resize", handleResize)
            .on("keydown", handleKeypress);

        /* SETUP ZOOM BEHAVIOR */

        const zoomHandler = d3.zoom()
            .scaleExtent([-Infinity,Infinity])
            .on("zoom", () => {
                chartArea.attr("transform", d3.event.transform)
            });

        zoomHandler(svg);

        /* UTILITY FUNCTIONS */

        //update position of nodes and edges every simulation tick
        function ticked() {
            nodes
//                .transition() //TEST
//                .duration(200) //TEST
//                .ease(d3.easeLinear)
                .attr("cx", d => d.x)
                .attr("cy", d => d.y);

            nodeLabels
//                .transition() //TEST
//                .duration(200) //TEST
//                .ease(d3.easeLinear)
                .attr("x", d => d.x)
                .attr("y", d => d.y);

            if (SHOW_EDGES) {
                edges
//                    .transition() //TEST
//                    .duration(200) //TEST
//                    .ease(d3.easeLinear)
                    .attr('d', d => 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y);
            }

            //Flips EdgeLabel so it won't appear upside-down
            if (EDGELABEL_KEEP_UPRIGHT) {
                edgeLabels.attr('transform', function (d) {
                    if (d.target.x < d.source.x) {
                        const bbox = this.getBBox();
                        const rx = bbox.x + bbox.width / 2;
                        const ry = bbox.y + bbox.height / 2;
                        return 'rotate(180 ' + rx + ' ' + ry + ')';
                    }
                    else {
                        return 'rotate(0)';
                    }
                });
            }
        }

        //Mouse interaction functions
        function dragstarted(d) {
            if (!d3.event.active) {
                simulation.alphaTarget(0.3).restart();
            }
            d.fx = d.x;
            d.fy = d.y;

            if (NODEDRAG_FIXES_POSITION) {
                d3.select(this).classed(classnames.fixed, true);
                fixEdgesConnectedTo(d);
            }
        }

        function dragged(d) {
            d.fx = d3.event.x;
            d.fy = d3.event.y;
        }

        function dragended(d) {
            if (!d3.event.active) {
                simulation.alphaTarget(0);
            }

            //if this node doesn't have the "fixed" classname applied, realease fx (fixed-x) and fy (fixed-y)
            if (!d3.select(this).classed(classnames.fixed)) {
                d.fx = null;
                d.fy = null;
            }
        }

        function handleRightClick(d) { //right-click
            d3.event.preventDefault(); //prevent the browser's normal right-click menu

            const wasThisNodeFixed = d3.select(this).classed(classnames.fixed);
            d3.select(this).classed(classnames.fixed, !wasThisNodeFixed);
            fixEdgesConnectedTo(d);
            flagReachableNodes(d);

            //un/fix node position
            d.fx = wasThisNodeFixed ? null : d.x;
            d.fy = wasThisNodeFixed ? null : d.y;
        }

        function handleMouseOver (d) {
            log('mouse over() d.id=' + d.id, 'at d.i=' + d.index, 'd_htmlID=' + d3.select(this).attr("id"), ' index in master=' + getNodeIndexFromMaster(d));
            d3.select(this)
                .attr('r', NODE_RADIUS + NODE_POP_SIZE)
                .transition()
                .duration(timings.nodePop)
                .attr('r', NODE_RADIUS);


            focusNeighborsOf(d);
            unfocusNonNeighborsOf(d);
        }

        function handleMouseOut (d) {
            svg.style("cursor","move");
            removeFocused(d);
            removeUnfocused(d);
        }

        function handleMouseDown(d) {
            d3.event.stopPropagation();

            focusNeighborsOf(d);
            unfocusNonNeighborsOf(d);
        }

        //functions for changing css classes
        function fixEdgesConnectedTo(subjectNode) {
            //curry function by supplying 1st arg. for convenience.
            const isFixed = isNodeClassed.bind(null, classnames.fixed);
            const isSubjectFixed = isFixed(subjectNode);

            //toggle-on classname='fixed' if the Edge is between 2 fixed nodes
            edges.filter(edge => edge.source === subjectNode) //edges w SubjectNode as the Source
                .classed(classnames.fixed, edge => isFixed(edge.target) && isSubjectFixed);

            edges.filter(edge => edge.target === subjectNode) //edges targeting the SubjectNode
                .classed(classnames.fixed, edge => isFixed(edge.source) && isSubjectFixed);

            edgeLabels.filter(edgeLabel => edgeLabel.source === subjectNode) //edges w SubjectNode as the Source
                .classed(classnames.fixed, edgeLabel => isFixed(edgeLabel.target) && isSubjectFixed);

            edgeLabels.filter(edgeLabel => edgeLabel.target === subjectNode) //edges targeting the SubjectNode
                .classed(classnames.fixed, edgeLabel => isFixed(edgeLabel.source) && isSubjectFixed);

            updateEdgeArrowheads();
        }

        function flagReachableNodes() {
            //curry function by supplying 1st arg. for convenience.
            const isFixed = isNodeClassed.bind(null, classnames.fixed);

            //initially remove all "reachable" class tags
            nodes.classed(classnames.reachable, false);

            edges.filter(edge => isFixed(edge.source)) //edges whose Source Node is Fixed
                .each(function (edge) {
                    selectNode(edge.target).classed(classnames.reachable, true);
                });

            edges.filter(edge => isFixed(edge.target)) //edges whose Target Node is Fixed
                .each(function (edge) {
                    selectNode(edge.source).classed(classnames.reachable, true);
                });

            //updateEdgeArrowheads();
        }

        //aa
        function focusNeighborsOf(subjectNode) {
            svg.style("cursor", "pointer");

            const isConnectedToSubjectNode = areNodesConnected.bind(null, subjectNode);

            nodes.classed(classnames.focused, isConnectedToSubjectNode);
            nodeLabels.classed(classnames.focused, isConnectedToSubjectNode);

            const isSubjectNodeInEdge = edge => isNodeInEdge(edge, subjectNode);
            edges.classed(classnames.focused, isSubjectNodeInEdge);
            edgeLabels.classed(classnames.focused, isSubjectNodeInEdge);

            updateEdgeArrowheads();
        }

        function unfocusNonNeighborsOf(subjectNode) {
            const isUnconnectedToSubjectNode = node => !areNodesConnected(subjectNode, node);

            nodes.classed(classnames.unfocused, isUnconnectedToSubjectNode);
            nodeLabels.classed(classnames.unfocused, isUnconnectedToSubjectNode);

            //TODO: next
            //const isSubjectNodeInEdge = edge => isNodeInEdge(edge, subjectNode);

            edges.classed(classnames.unfocused, edge =>
                !(edge.source === subjectNode || subjectNode === edge.target)
            );
            edgeLabels.classed(classnames.unfocused, edgeLabel =>
                !(edgeLabel.source === subjectNode || subjectNode === edgeLabel.target)
            );

            updateEdgeArrowheads();
        }

        function removeFocused() {
            nodes.classed(classnames.focused, false);
            nodeLabels.classed(classnames.focused, false);
            edges.classed(classnames.focused, false);
            edgeLabels.classed(classnames.focused, false);

            updateEdgeArrowheads();
        }

        function removeUnfocused() {
            nodes.classed(classnames.unfocused, false);
            nodeLabels.classed(classnames.unfocused, false);
            edges.classed(classnames.unfocused, false);
            edgeLabels.classed(classnames.unfocused, false);

            updateEdgeArrowheads();
        }

        function createArrowheads() {
            if (!SHOW_EDGE_ARROWHEADS) {
                return;
            }

            createArrowheadMarker(classnames.arrowhead, ids.arrowheadNeutral);
            createArrowheadMarker(classnames.arrowhead, ids.arrowheadFocused);
            createArrowheadMarker(classnames.arrowhead, ids.arrowheadUnfocused);
            createArrowheadMarker(classnames.arrowhead, ids.arrowheadFixed);
        }

        function updateEdgeArrowheads() {
            if (!SHOW_EDGE_ARROWHEADS) {
                return;
            }
            //use the arrowhead that matches the edge
            edges.each(function (){
                const thisEdge = d3.select(this); //convenience var

                //select by priority
                if (thisEdge.classed(classnames.focused)){
                    thisEdge.attr('marker-end', formatMarkerUrl(ids.arrowheadFocused));
                } else if (thisEdge.classed(classnames.fixed)) {
                    thisEdge.attr('marker-end', formatMarkerUrl(ids.arrowheadFixed));
                } else if (thisEdge.classed(classnames.unfocused)) {
                    thisEdge.attr('marker-end', formatMarkerUrl(ids.arrowheadUnfocused));
                } else {
                    thisEdge.attr('marker-end', formatMarkerUrl(ids.arrowheadNeutral));
                }
            });
        }

        function createArrowheadMarker(classname, id) {
            chartArea.append('defs')
                .append('marker')
                .attrs({
                    'id': id,
                    'class': classname,
                    'viewBox': '-0 -5 10 10',
                    'refX': EDGE_ARROWHEAD_OFFSET,
                    'refY': 0,
                    'orient': 'auto',
                    'markerWidth' :7,
                    'markerHeight' :7,
                    'xoverflow': 'visible'})
                .append('svg:path')
                .attr('d', 'M 0,-5 L 10 ,0 L 0,5');
        }

        //convenience/utility functions
        function cloneGraph(data){
            return {
                nodes: JSON.parse(JSON.stringify(data.nodes)), //deep copy
                edges: concatLabelsOfSimilarEdges(JSON.parse(JSON.stringify(data.edges))) //deep copy and concat labels of same edges
            };

            function concatLabelsOfSimilarEdges(edges){
                return edges.reduce(function(accum, e){
                    const matchingEdges = accum.filter(d => d.source === e.source && d.target === e.target);
                    if (!matchingEdges.length) {
                        const clone = {
                            id: e.id,
                            source: e.source,
                            target: e.target,
                            label: e.label
                        };
                        accum.push(clone);
                        return accum;
                    }

                    //concatenate labels
                    matchingEdges[0].label += ', ' + e.label;
                    return accum;
                }, [])
            }
        }

        function log(msg){
            console.log.apply(null, arguments);
        }

        //bb
        // filters
        function areNodesConnected(a, b) {
            const doAAndBBelongToEdge = doNodesBelongInEdge.bind(null, a, b);
            return graphCurrentSelection.edges.filter(doAAndBBelongToEdge).length;
        }

        function doNodesBelongInEdge(node1, node2, edge){
            return (node1 === edge.source && edge.target === node2) ||
                (node2 === edge.source && edge.target === node1) ||
                node1 === node2;
        }

        function isNodeClassed(className, node) {
            return d3.select("#node" + getNodeIndexFromMaster(node)).classed(className);
        }

        function selectNode(node) {
            return d3.select("#node" + getNodeIndexFromMaster(node));
        }

        function formatMarkerUrl(id){
            return 'url(#' + id + ')';
        }

        //key press handler

        let showP = true;

        function handleKeypress() {
            const keycode = {
                l: 76,
                n: 78,
                e: 69,
                p: 80,
                space: 32
            };

            console.log('Key pressed: d3.event.keyCode=' + d3.event.keyCode);

            if (d3.event.keyCode === keycode.space) {
                simulation.stop();
            }

            if (d3.event.keyCode === keycode.n) {
                log('*** selected nodes ***\n', graphCurrentSelection.nodes);
            }

            if (d3.event.keyCode === keycode.e) {
                log('*** selected edges ***\n', graphCurrentSelection.edges);
            }

            if (d3.event.keyCode === keycode.p) { //p
                d3.event.stopPropagation();

                showP = !showP;

                toggleNodes(f, showP);

                function f(e){ //filter
                    return e.id.substring(0, 1).toLowerCase() === 'p';
                }
            }
        }

        function isEdgeInNodes(subjectEdge, nodes){
            const isNodeInSubjectEdge = isNodeInEdge.bind(null, subjectEdge);
            return nodes.filter(isNodeInSubjectEdge).length;
        }

        function isNodeInEdge(edge, node) {
            return edge.source === node || node === edge.target;
        }

        function isNodeInNodes(subjectNode, nodes){
            return nodes.filter(node => node === subjectNode).length;
        }

        function isEdgeInEdges(subjectEdge, edges){
            return edges.filter(edge => edge === subjectEdge).length;
        }

        function toggleNodes(filterFunction, showNodes){
            //get nodes and edges from the master
            const nodesToToggle = graphMaster.nodes.filter(filterFunction);
            const edgesToToggle = graphMaster.edges.filter(edge =>
                showNodes ? isEdgeInNodes(edge, nodesToToggle) : !isEdgeInNodes(edge, nodesToToggle));

            //add/remove items-to-toggle to the current selection
            if (showNodes){
                graphCurrentSelection.nodes = graphCurrentSelection.nodes.concat(nodesToToggle);
                graphCurrentSelection.edges = graphCurrentSelection.edges.concat(edgesToToggle);
            } else {
                graphCurrentSelection.nodes =
                    graphCurrentSelection.nodes.filter(node => !isNodeInNodes(node, nodesToToggle));

                graphCurrentSelection.edges =
                    graphCurrentSelection.edges.filter(edge => isEdgeInEdges(edge, edgesToToggle));
            }

            redraw(graphCurrentSelection.nodes, graphCurrentSelection.edges);

            //Restart force simulation after transitions have completed
            restartSimulation(graphCurrentSelection.nodes, graphCurrentSelection.edges, timings.nodeExit);

            flagReachableNodes();
        }

        function redraw(newNodes, newEdges){
            /* EDGES */
            edges = edges.data(newEdges, getEdgeIndexFromMaster);

            edges.exit()
                .transition()
                .duration(timings.nodeExit)
                .remove();

            edges = edges.enter()
                .append('path')
                .style("pointer-events", "none")
                .attrs({
                    'class': 'edge',
                    'id': edge => 'edge' + getEdgeIndexFromMaster(edge)
                })
                .merge(edges);

            updateEdgeArrowheads();

            /* EDGE LABELS */
            edgeLabels = edgeLabels.data(newEdges, getEdgeIndexFromMaster);

            edgeLabels.exit()
                .transition()
                .duration(timings.nodeExit)
                .remove();

            edgeLabels = edgeLabels.enter()
                .append("text")
                .style("pointer-events", "none")
                .append('textPath')
                .style("pointer-events", "none")
                .attrs({
                    "class": "edgelabel",
                    "id": edge => classnames.edgeLabel + getEdgeIndexFromMaster(edge),
                    "xlink:href": edge => '#edge' + getEdgeIndexFromMaster(edge),
                    "startOffset": "50%"
                })
                .text(edge => edge.label)
                .merge(edgeLabels);

            /* NODES */
            nodes = nodes.data(newNodes, getNodeIndexFromMaster);

            nodes.exit()
                .transition()
                .duration(timings.nodeExit)
                .attr('r', 0)
                .remove();

            nodes = nodes.enter()
                .append("circle")
                .attrs({
                    "class": classnames.node,
                    "r": '1',
                    //"id": node => classnames.node + node.id
                    "id": node => classnames.node + getNodeIndexFromMaster(node)
                })
                .on('contextmenu', handleRightClick)
                .on("mouseover", handleMouseOver)
                .on("mouseout", handleMouseOut)
                .on("mousedown", handleMouseDown)
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended)
                )
                .merge(nodes);

            nodes.transition()
                .duration(timings.nodeEnter)
                .ease(d3.easeBounce)
                .attr('r', NODE_RADIUS);

            /* NODE LABELS */
            nodeLabels = nodeLabels.data(newNodes, getNodeIndexFromMaster);

            nodeLabels.exit()
                .remove();

            nodeLabels = nodeLabels.enter()
                .append("text")
                .attrs({
                    "class": classnames.nodeLabel,
                    "dy": ".35em"
                })
                .text(nodeLabel => nodeLabel.id)
                .merge(nodeLabels);
        }

        function getNodeIndexFromMaster(node){
            return graphMaster.nodes.indexOf(node);
        }

        function getEdgeIndexFromMaster(edge){
            return graphMaster.edges.indexOf(edge);
        }

        function restartSimulation(newNodes, newEdges, delay) {
            setTimeout(function() {
                simulation.nodes(newNodes);
                simulation.force("link").links(newEdges);
                simulation.alpha(1).restart(); //alpha so joins don't make the screen jump
            }, delay)
        }

        //if tick rate is too far apart, adapt the target framerate by backing off render calls
        function AdaptiveFramerate(maxTicksToSkip, maxWaitTime){
			const _maxTicksToSkip = (maxTicksToSkip || 5);
			const _maxWaitTime = maxWaitTime || 200;

            const scale = d3.scaleLinear()
                .domain([16, _maxWaitTime])
                .rangeRound([0, _maxTicksToSkip]) //round to int
                .clamp(true); //do not go beyond specified ranges

            let lastUpdateTime = new Date();
            let remainingTicksToSkip = 0;

//            let first = true;

			return {
				isTimeForUpdate: function () {
				    return true;
//				    if (first) {
//                        first = false;
//                        console.log('input=' + 0, 'value=' + scale(0));
//                        console.log('input=' + 50, 'value=' + scale(50));
//                        console.log('input=' + 100, 'value=' + scale(100));
//                        console.log('input=' + 150, 'value=' + scale(150));
//                        console.log('input=' + 200, 'value=' + scale(200));
//                        console.log('input=' + 300, 'value=' + scale(300));
//                        console.log('input=' + 400, 'value=' + scale(400));
//                    }
//				    return true;

                    remainingTicksToSkip--;

                    if (remainingTicksToSkip > 0) {
                        console.log('tick skipped');
                        return false;
                    }

                    const now = new Date();
                    const deltaTime = now - lastUpdateTime;
                    remainingTicksToSkip = scale(deltaTime); //scale based on delta time

                    console.log('deltaTime=' + deltaTime, 'remainingTicksToSkip=' + remainingTicksToSkip);

                    lastUpdateTime = now;
                    return true;
				}
			}
        }
    }
    //END OF MAIN

</script>
